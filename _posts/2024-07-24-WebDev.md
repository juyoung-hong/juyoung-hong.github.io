---
layout: single
author_profile: true
permalink: /categories/web/web_develop
sidebar: 
  nav: "docs"
title: 웹 개발의 이해
toc: true
category: web
---

<br>

# 프로그래밍 언어

<br>

## 저급언어

- 2진수로 이뤄진 값으로 작성하는 기계 중심의 언어 (기계어)

유지보수가 어려우며, 사용이 어렵기 때문에 숫자로 된 문장과 1:1로 대응하는 기호를 만들고, 해당 기호로 프로그래밍을 하게 됨.

기호로 작성한 프로그램은 기계가 알아들을 수 없어, 원래의 숫자로 변환하는 과정이 필요하게 되었으며, 이 과정에서 사용되는 도구를 컴파일러라고 하고, 기호로 작성된 언어를 어셈블리어라고 한다.

현재는 아주 특수한 경우(임베디드 시스템과 같이 제한된 환경)를 제외하고는 기계어와 어셈블리어로 프로그램을 개발하는 경우는 거의 없다.

```Assembly
ADD EAX EBX
```

위와 같은 명령어의 경우 EBX의 값을 EAX에 더하는 프로그램이 됨 (Intel 방식)

## 고급 언어

- 사람이 이해하기 쉬운 문법으로 프로그래밍 하는 언어 

작성한 소스코드를 번역하는 과정이 필요하며, 해당 과정을 컴파일, 컴파일을 수행하는 것을 컴파일러라고 함.

## 웹 프로그래밍에서 인기가 많은 언어

### GITHUB

- JAVA SCRIPT
- PYTHON
- JAVA
- RUBY
- PHP

### tiobe

- JAVA
- C
- C++
- PYTHON
- C#

1. PYTHON: 프로그램 입문자가 읽기 쉽고, 적은 코드를 사용하여 개발 가능
2. PHP: 웹 개발에서 많이 사용 됨
3. Java Script: 프론트엔드 개발자라면 반드시 알아야하는 언어
4. JAVA: 엔터프라이즈 소프트웨어 환경에 잘 맞는 언어
5. Ruby: 빠른 개발에 널리 사용되며, 단순하고 세련된 웹 어플리케이션을 만들 수 있음.

# HTTP의 이해

물리적인 하나의 컴퓨터에는 여러개의 서버가 동작할 수 있으며, 각 서버들은 port라는 값으로 구분하여 동작한다.

|이름|프로토콜|포트|기능|
|:---:|:---:|:---:|:---:|
|www|http|80|웹서비스|
|email|smtp/pop3/imap|25/110/114|이메일 서비스|
|ftp|ftp|21|파일 전송 서비스|
|dns|tcp/udp|53|네임서비스|
|news|nntp|119|인터넷 뉴스 서비스|

- 인터넷: 수많은 네트워크들이 연결된 네트워크 (TCP/IP 라는 약속으로 연결되어 있음)

## HTTP

**Hypertext Transfer Protocol:** 서버와 클라이언트가 인터넷상에서 데이터를 주고 받기 위한 프로토콜 (이미지, 동영상, 오디오, 텍스트 문서 등 종류를 가리지 않고 전송할 수 있음)

HTTP는 서버/클라이언트 모델을 따름 (클라이언트가 서버에게 요청을 보내면, 서버는 클라이언트에게 응답을 보내게 된다.)

클라이언트가 먼저 서버에게 요청을 보내고, 해당 요청에 대해 서버가 응답하는 구조

HTTP는 무상태 프로토콜이라고도 한다.

서버는 클라이언트에게 응답한 이후 바로 연결을 끊어버리기 때문에, 다음 요청이 들어왔을때 아까 그 클라이언트인지 아닌지 알 수 없음. (stateless 방식)

- 장점
  - 불특정 다수를 대상으로 하는 서비스에 적합함
  - 계속 연결 상태를 유지 하지 않기 때문에, 클라이언트와 서버가 훨씬 많은 요청과 응답을 수행할 수 있다.

- 단점
  - 바로 연결을 끊어버리기 때문에 클라이언트가 무엇을 했는지 알 수 없음.
  - 이러한 문제를 해결하고 정보를 유지하기 위해서 Cookie라는 개념이 등장하게 됨.

## URL

**Uniform Resource Locator:** 인터넷 상의 자원의 위치

1. 접근 프로토콜의 종류
2. 자원이 있는 서버의 IP주소 또는 도메인주소와 포트번호
3. 자원의 위치 (해당 컴퓨터 안에 있는 파일의 경로)
4. 자원의 이름 (파일 명)

### 웹서버 통신 방식

1. 클라이언트가 원하는 서버에 접속함
2. 클라이언트가 서버에게 요청 (정해진 규칙에 따라 요청: 요청 메시지는 헤더와 바디로 나뉨)
3. 서버가 클라이언트에게 응답 (역시 헤더와 바디로 나뉨)
4. 응답 이후 서버와 클라이언트의 연결을 끊음

**요청 헤더:** 
- 요청 메서드: GET / POST 등
- 요청 URI: 요청하는 자원의 위치를 명시
- 프로토콜의 버전: HTTP 프로토콜의 버전을 명시
- 호스트 주소, 브라우저 정보, 언어 등

**요청 바디**
요청 메서드가 POST 또는 PUT일때 존재하게 됨

**응답 헤더:** 
- 프로토콜의 버전: HTTP 프로토콜의 버전을 명시
- 응답 코드 (200 등)
- 응답 메시지 (OK 등)
- 날짜, 웹서버, 컨텐츠 타입, 컨텐츠 길이 등

**응답 바디**
실제 응답 데이터 리소스

### 메서드 종류
- GET : 정보를 요청하기 위해서 사용한다. (SELECT)
- POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)
- PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)
- DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)
- HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.
- OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.
- TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨데 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

# 웹 프론트엔드

사용자에게 웹을 통해 다양한 콘텐츠(문서, 동영상, 사진 등)를 제공하며, 사용자의 요청에 반응해서 동작함.

## 역할

(HTML) 콘텐츠를 잘 보여주기 위한 구조를 만들어야 하며, (CSS) 적절한 배치와 일관된 디자인으로 (JavaScript) 사용자의 요청을 잘 반영해야 한다.

# 웹 백엔드

- 프론트 엔드: 클라이언트 사이드
- 백 엔드: 서버 사이드

## browser의 역할

- 브라우저 엔진: 소스코드를 해석하는 엔진
- 렌더링 엔진: 실제로 화면을 픽셀 단위로 색칠해주는 엔진 (Webkit, Blink)
- 특정 주소에 해당하는 문서를 받아오므로 네트워킹이 필요하며,
- Java Script를 해석하는 엔진이 필요하고,
- UI를 해석하는 백엔드 엔진이 필요하다.

### 렌더링 엔진

1. HTML을 파싱하여, DOM(Document Object Model) Tree를 구축함.
2. CSS를 파싱한 Style Rule과 DOM을 합쳐서 Render Tree를 만들고,
3. Render Tree를 기준으로 스타일 정보와 구조를 합쳐서 화면에 어떻게 배치할지를 결정한다.
4. 화면에 직접 그린다.

HTML은 계층적으로 구성되어, 일종의 트리형태로 표현할 수 있다 (DOM tree)

CSS는 Selector(어떤곳에 적용할지)와 Declaration(무엇을 적용할지, Key-Value 형태)으로 구분된다.

## HTML

- head: HTML 문서에 대한 추가적인 설명 (눈에 보이지 않는 문서에 대한 설명)
- body: 화면에 표현되어야 할 내용들
- tag를 사용하여 표현하며, javascript와 CSS가 html 안에 여기저기 존재할 수 있다.

javascript는 아무 곳에나 넣을 수 있지만, body 태그 뒷부분의 html 끝나는 부분에 넣어주는 것이 일반적인 방식이다.

(위쪽에 넣게 되면, js 파일을 다운 받는 동안, html 해석이 느려질 수 있다.)

CSS 코드는 주로 head 안에 존재한다.

CSS 또는 JS 코드가 길어지게 되면, 별도의 파일로 작성하여 link 할 수 있다.

## 웹서버

클라이언트와 서버는 주로 http 프로토콜로 데이터를 주고 받음.

웹 브라우저는 웹서버로부터 전달받은 html 문서를 해석하고, 해당 문서에 포함된 url들에 대해서, 여러가지 자원을 동시에 요청하게 된다.

웹 서버는 여러 요청을 받아, 그 결과를 브라우저에 전달하고, 브라우저는 해석한 문서와 요청했던 많은 결과를 조합하여 화면을 구성(렌더링)하게 된다.

- 웹 서버 소프트웨어의 종류
- Apache, Nginx, Microsoft, Google 웹서버

## WAS

DBMS(database management system)는 보통 서버 형태로 서비스를 제공하게 되며, DBMS에 접속하여 동작하는 클라이언트가 많아지게 되었다.

그러나 이러한 방식으로 동작하는 클라이언트 프로그램의 로직이 복잡해지고, 클라이언트 프로그램의 크기가 커지는 문제가 있었다. (로직 변경시 클라이언트가 매번 배포되어야함)

그래서 DBMS를 클라이언트가 직접 연결하여 동작하는 것이 아닌, 미들웨어를 통해서 동작하게 함으로써, 클라이언트는 입력과 출력만 담당하도록 하였다.

미들웨어는 대부분의 로직을 수행하고, 결과를 클라이언트에게 보내게 되고, 클라이언트는 사용자에게 입력만 받아서 미들웨어에게 보내는 역할을 수행하고 결과를 받아서 화면에 뿌려주기만 하면 되므로 크기가 작아지고, 로직이 변경되더라도 모든 클라이언트를 배포할 필요없이 미들웨어만 변경하면 되었다.

최초에 Web은 정적 데이터만 보여주었으나, 데이터를 입력하고 조회하는 동적인 기능을 요구하게 되며 점점 복잡한 로직을 담게 되었고, 대부분 DMBS와 관련되어 미들웨어(WAS)가 필요하게되었다.

### WAS의 주요 기능
- 프로그램 실행 환경과 DBMS 접속 기능을 제공
- 여러개의 트랜잭션(논리적인 작업 단위)을 관리
- 업무를 처리하는 비즈니스 로직을 수행

WAS도 보통 자체적으로 웹서버 기능을 내장하고 있고, 정적 컨텐츠를 처리하는데 있어 성능상 큰 차이는 없지만, 규모가 커질수록 웹서버와 WAS를 분리하며, 그 목적은 장애 극복(failover)기능인 경우가 많다.

WAS 자체에 문제가 발생하는 경우, 재시작이 필요할 수 있고, 앞단의 웹서버에서 해당 WAS를 사용하지 못하도록 하고, 로드밸런서 등을 활용하여 사용자는 이런 문제를 모르도록 할 수 있다.